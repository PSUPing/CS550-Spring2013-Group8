(define (boolexp expr)
   (cond ((list? expr)
      (cond ((eq? (car expr) 'boolexp) (boolexp (cadr expr)))
            ((eq? (car expr) 'and) (eval-and (cdr expr)))
            ((eq? (car expr) 'or) (eval-or (cdr expr)))
            ((eq? (car expr) 'not) (eval-not (cadr expr)))
            ((eq? (car expr) 'implies) (eval-implies (cadr expr) (car (reverse expr))))
            ((eq? (car expr) 'equiv) (eval-equiv (cadr expr) (car (reverse expr))))
            ((boolean? (car expr)) (car expr))
            ((list? (car expr)) (boolexp (car expr)))))
          ((boolean? expr) expr)
          (else "Symbol Error")))

 
(define (eval-and expr)
   (if (null? (cdr expr))
      (boolexp expr)
      (and (boolexp (car expr)) (eval-and (cdr expr)))))
 
(define (eval-or expr)
   (if (null? (cdr expr))
      (boolexp expr)
      (or (boolexp (car expr)) (eval-or (cdr expr)))))
 
(define (eval-not expr)
   (not (boolexp expr)))
 
(define (eval-implies expr1 expr2)
   (cond ((and (eq? (boolexp expr1) #t) (eq? (boolexp expr2) #t)) #t)
         ((and (eq? (boolexp expr1) #t) (eq? (boolexp expr2) #f)) #f)
         ((and (eq? (boolexp expr1) #f) (eq? (boolexp expr2) #t)) #t)
         ((and (eq? (boolexp expr1) #f) (eq? (boolexp expr2) #f)) #t)
         (else "Symbol Error")))
 
(define (eval-equiv expr1 expr2)
   (cond ((and (eq? (boolexp expr1) #t) (eq? (boolexp expr2) #t)) #t)
         ((and (eq? (boolexp expr1) #t) (eq? (boolexp expr2) #f)) #f)
         ((and (eq? (boolexp expr1) #f) (eq? (boolexp expr2) #t)) #f)
         ((and (eq? (boolexp expr1) #f) (eq? (boolexp expr2) #f)) #t)
         (else "Symbol Error")))
 
;(define P #t)
 
;(define Q #f)
 
;(define negativeTest 348284)
 
;(define simpleTest (list 'boolexp P))
 
;(define andTest (list 'and P Q))
 
;(define orTest (list 'or P Q))
 
;(define notTest (list 'not P))
 
;(define simpleTest (list 'not P))
 
;(define impliesTest (list 'implies P Q))
 
;(define equivTest (list 'equiv Q Q))
 
;(define taut1 (list 'or P (list 'not P)))
 
;(define taut2 (list 'equiv (list 'or P Q) (list 'or Q P)))
 
;(define taut3 (list 'equiv (list 'or P Q) (list 'or P (list 'and (list 'not P) Q))))

;Returns a list of pairs consisting of variable and #f
;one entry for each variable in the statement
(define (extractVars l)
	(extractHelper (tokenizer l) '())
)

;Does the real work of the extraVars method
(define (extractHelper i o)
	(if (null? i)
		o
		(if (contains (car i) o)
			(extractHelper (cdr i) o)
			(extractHelper (cdr i) (cons (cons (car i) '(#f)) o))
		)
	)
)

;Makes the input a flat list of tokens
(define (tokenizer l)
	(if (null? l)
		'()
		(if (list? l)
			(merge (tokenizer (car l)) (tokenizer (cdr l)))
			(cons l '())
		)
	)
)

;merges two lists into one concatenated list
(define (merge a b)
	(if (null? a) 
		b
		(if (null? b) 
			a
			(cons (car a) (cons (car b) (merge (cdr a) (cdr b))))
		)
	)
)
	

;Checks whehter the value i is already in the list o
;Also returns true if the value should not be added because it is not
;a variable
(define (contains i o)
	(cond 
		((eq? i #t) #t)
		((eq? i #f) #t)
		((eq? i 'and) #t)
		((eq? i 'or) #t)
		((eq? i 'not) #t)
		((eq? i 'implies) #t)
		((eq? i 'equiv) #t)
		((null? o) #f)
		((eq? i (caar o)) #t)
		(else (contains i (cdr o)))
	)
)

;Evaluates the expression in the given environment
(define (envEval expr env)
	(envEvalHelper expr env '())
)

;Does the work of evaluating the expression in the given environment
(define (envEvalHelper expr env out)
	(if (list? expr)
		(if (null? expr)
			'()
			(cons 
				(envEvalHelper (car expr) env out) 
				(envEvalHelper (cdr expr) env out)
			)
		)
		(if (contains expr env)
			(get expr env)
			expr
		)
	)
)

;Returns the value for the given identifier in the given environment
(define (get expr env)
	(if (null? env)
		expr
		(if (eq? (caar env) expr)
			(cadar env)
			(get expr (cdr env))
		)
	)
)

;Gets the next environment by "Adding one" which is treating the variables
;as if they are digits in a binary number and adding one to get the next
;number
(define (addone env)
	(reverse (addoneHelper env '()))
)

;Flips all the #t to #f until it encounters a #f which it will flip to a #t.
;If it never encounters one it returns '() to indicate it is done
(define (addoneHelper env out)
	(if (null? env)
		'()
		(if (cadar env)
			(addoneHelper (cdr env) (cons (cons (caar env) '(#f)) out)) 
			(addoneHelperR (cdr env) (cons (cons (caar env) '(#t)) out)) 
		)
	)	
)

;copies the rest of the list after the frist #f has been found and flipped
(define (addoneHelperR env out)
	(if (null? env)
		out
		(cons (car env) out)
	)
)

;checks to see if the expression is true in the given environment and is
;true in all future environments generated by "adding one"
;Basically does the heavy lifting of taut?
(define (check expr env)
	(if (null? env)
		(if (eq? expr #f)
			#f
			#t
		)
		(let(
			(current (envEval expr env))
			(rest (check expr (addone env)))
			)
			(boolexp 
				(list 'and current rest)
			)
		)
	)
)

;Determines whether the given expression is a tautology
(define (taut? expr)
	(check expr (extractVars expr))
)
